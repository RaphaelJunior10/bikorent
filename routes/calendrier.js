const express = require('express');
const router = express.Router();
const { firestoreUtils } = require('../config/firebase');
const dataService = require('../services/dataService');

// Fonction helper pour v√©rifier le plan utilisateur
async function checkUserPlan(req, res, next) {
    try {
        if (!req.session.user) {
            return res.status(401).json({ success: false, message: 'Non autoris√©' });
        }

        const user = await dataService.getUserById(req.session.user.id);
        if (!user) {
            return res.status(401).json({ success: false, message: 'Utilisateur non trouv√©' });
        }

        const userPlan = user.facturation?.planId || 'basique';
        if (userPlan !== 'enterprise') {
            return res.status(403).json({ 
                success: false, 
                message: 'Seuls les membres Entreprise ont acc√®s √† cette fonctionnalit√©. Mettez √† jour votre forfait pour y acc√©der.',
                requiredPlan: 'enterprise'
            });
        }

        next();
    } catch (error) {
        console.error('‚ùå Erreur v√©rification plan:', error);
        return res.status(500).json({ success: false, message: 'Erreur serveur' });
    }
}

// Page principale du calendrier
router.get('/', async (req, res) => {
    try {
        // V√©rifier si l'utilisateur est connect√©
        if (!req.session.user) {
            return res.redirect('/auth/login');
        }

        // V√©rifier le plan de l'utilisateur
        const user = await dataService.getUserById(req.session.user.id);
        if (!user) {
            console.log('‚ùå Utilisateur non trouv√©');
            return res.redirect('/auth/login');
        }

        // V√©rifier si l'utilisateur a un plan Entreprise
        const userPlan = user.facturation?.planId || 'basique';
        console.log(`üîç Plan utilisateur: ${userPlan}`);
        
        if (userPlan !== 'enterprise') {
            console.log('‚ùå Acc√®s refus√© - Plan insuffisant');
            return res.render('upgrade-required', {
                title: 'Acc√®s refus√© - BikoRent',
                currentPage: 'calendrier',
                pageTitle: 'Acc√®s refus√©',
                isAuthenticated: true,
                user: req.session.user,
                message: 'Seuls les membres Entreprise ont acc√®s √† cette fonctionnalit√©. Mettez √† jour votre forfait pour y acc√©der.',
                requiredPlan: 'enterprise'
            });
        }
        
        console.log('‚úÖ Acc√®s accord√© - plan entreprise d√©tect√©');

        // R√©cup√©rer les propri√©t√©s de l'utilisateur pour les √©v√©nements
        const properties = await getPropertiesFromDatabase();
        const userProperties = properties.filter(property => 
            property.ownerId === req.session.user.id || 
            property.tenantId === req.session.user.id
        );

        // R√©cup√©rer les √©v√©nements existants
        let events = await getCalendarEvents(req.session.user.id);
        
        // Ajouter les √©v√©nements automatiques bas√©s sur les propri√©t√©s et paiements r√©els
        const automaticEvents = await generateAutomaticEvents(userProperties, req.session.user.id);
        events = [...events, ...automaticEvents];
        
        // Ajouter les √©v√©nements bas√©s sur les paiements r√©els
        const paymentEvents = await generatePaymentEvents(req.session.user.id);
        events = [...events, ...paymentEvents];

        res.render('calendrier', {
            title: 'Calendrier - BikoRent',
            currentPage: 'calendrier',
            pageTitle: 'Calendrier',
            properties: userProperties,
            events: events,
            isAuthenticated: !!req.session.user,
            user: req.session.user
        });

    } catch (error) {
        console.error('Erreur lors du chargement du calendrier:', error);
        res.status(500).render('error', {
            title: 'Erreur - BikoRent',
            message: 'Une erreur est survenue lors du chargement du calendrier.',
            layout: false
        });
    }
});

// API pour cr√©er un nouvel √©v√©nement
router.post('/api/events', checkUserPlan, async (req, res) => {
    try {

        const { title, description, start, end, propertyId, eventType, location } = req.body;

        // Validation des donn√©es
        if (!title || !start || !end || !eventType) {
            return res.status(400).json({ 
                success: false, 
                message: 'Titre, dates et type d\'√©v√©nement requis' 
            });
        }

        const eventData = {
            //id: generateEventId(),
            title: title,
            description: description || '',
            start: new Date(start),
            end: new Date(end),
            propertyId: propertyId || null,
            eventType: eventType, // 'visite', 'paiement', 'expiration', 'custom'
            location: location || '',
            userId: req.session.user.id,
            createdAt: new Date(),
            googleCalendarId: null // Sera rempli lors de la synchronisation
        };

        // Sauvegarder l'√©v√©nement
        await saveCalendarEvent(eventData);

        // Synchroniser avec Google Calendar si configur√©
        if (req.session.user.googleCalendarConnected) {
            const googleEventId = await syncWithGoogleCalendar(eventData, req.session.user);
            eventData.googleCalendarId = googleEventId;
            await updateCalendarEvent(eventData.id, { googleCalendarId: googleEventId });
        }

        res.json({ 
            success: true, 
            event: eventData,
            message: '√âv√©nement cr√©√© avec succ√®s'
        });

    } catch (error) {
        console.error('Erreur lors de la cr√©ation de l\'√©v√©nement:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Erreur lors de la cr√©ation de l\'√©v√©nement' 
        });
    }
});

// API pour r√©cup√©rer les √©v√©nements d'une p√©riode
router.get('/api/events', checkUserPlan, async (req, res) => {
    try {

        const { start, end, propertyId } = req.query;
        
        // R√©cup√©rer les √©v√©nements de calendrier de base
        let events = await getCalendarEvents(req.session.user.id, {
            start: start ? new Date(start) : null,
            end: end ? new Date(end) : null,
            propertyId: propertyId || null
        });

        // R√©cup√©rer les propri√©t√©s de l'utilisateur pour les √©v√©nements automatiques
        const allProperties = await firestoreUtils.getAll('properties');
        const userProperties = allProperties.filter(property => 
            property.ownerId === req.session.user.id || property.userId === req.session.user.id
        );

        // Ajouter les √©v√©nements automatiques bas√©s sur les propri√©t√©s
        const automaticEvents = await generateAutomaticEvents(userProperties, req.session.user.id);
        events = [...events, ...automaticEvents];

        // Ajouter les √©v√©nements bas√©s sur les paiements r√©els
        const paymentEvents = await generatePaymentEvents(req.session.user.id);
        events = [...events, ...paymentEvents];

        // D√©duplication des √©v√©nements bas√©e sur l'ID
        const uniqueEvents = [];
        const seenIds = new Set();
        
        for (const event of events) {
            if (!seenIds.has(event.id)) {
                seenIds.add(event.id);
                uniqueEvents.push(event);
            } else {
                console.log(`‚ö†Ô∏è √âv√©nement dupliqu√© d√©tect√© et supprim√©: ${event.id} - ${event.title}`);
            }
        }

        console.log(`üìä API /events: ${uniqueEvents.length} √©v√©nements uniques retourn√©s (${automaticEvents.length} automatiques, ${paymentEvents.length} paiements)`);

        res.json(uniqueEvents);

    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des √©v√©nements:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Erreur lors de la r√©cup√©ration des √©v√©nements' 
        });
    }
});

// API pour mettre √† jour un √©v√©nement
router.put('/api/events/:id', checkUserPlan, async (req, res) => {
    try {

        const eventId = req.params.id;
        const updates = req.body;

        // V√©rifier que l'√©v√©nement appartient √† l'utilisateur
        const existingEvent = await getCalendarEventById(eventId);
        if (!existingEvent || existingEvent.userId !== req.session.user.id) {
            return res.status(403).json({ 
                success: false, 
                message: '√âv√©nement non trouv√© ou non autoris√©' 
            });
        }

        // Mettre √† jour l'√©v√©nement
        const updatedEvent = await updateCalendarEvent(eventId, updates);

        // Synchroniser avec Google Calendar si n√©cessaire
        if (req.session.user.googleCalendarConnected && existingEvent.googleCalendarId) {
            await updateGoogleCalendarEvent(existingEvent.googleCalendarId, updates);
        }

        res.json({ 
            success: true, 
            event: updatedEvent,
            message: '√âv√©nement mis √† jour avec succ√®s'
        });

    } catch (error) {
        console.error('Erreur lors de la mise √† jour de l\'√©v√©nement:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Erreur lors de la mise √† jour de l\'√©v√©nement' 
        });
    }
});

// API pour supprimer un √©v√©nement
router.delete('/api/events/:id', checkUserPlan, async (req, res) => {
    try {

        const eventId = req.params.id;

        // V√©rifier que l'√©v√©nement appartient √† l'utilisateur
        const existingEvent = await getCalendarEventById(eventId);
        if (!existingEvent || existingEvent.userId !== req.session.user.id) {
            return res.status(403).json({ 
                success: false, 
                message: '√âv√©nement non trouv√© ou non autoris√©' 
            });
        }

        // Supprimer de Google Calendar si n√©cessaire
        if (req.session.user.googleCalendarConnected && existingEvent.googleCalendarId) {
            await deleteGoogleCalendarEvent(existingEvent.googleCalendarId);
        }

        // Supprimer l'√©v√©nement
        await deleteCalendarEvent(eventId);

        res.json({ 
            success: true, 
            message: '√âv√©nement supprim√© avec succ√®s'
        });

    } catch (error) {
        console.error('Erreur lors de la suppression de l\'√©v√©nement:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Erreur lors de la suppression de l\'√©v√©nement' 
        });
    }
});

// API temporaire pour configurer le plan entreprise (√† supprimer en production)
router.post('/api/setup-enterprise', async (req, res) => {
    try {
        if (!req.session.user) {
            return res.status(401).json({ success: false, message: 'Non autoris√©' });
        }

        const userId = req.session.user.id;
        
        // V√©rifier si Firebase est initialis√©
        if (!firestoreUtils.isInitialized()) {
            return res.json({ 
                success: true, 
                message: 'Mode test - plan entreprise automatiquement activ√©',
                plan: { plan: 'entreprise', status: 'active' }
            });
        }

        // Cr√©er ou mettre √† jour le plan entreprise
        const existingPlans = await firestoreUtils.getAll('billingPlans');
        const existingPlan = existingPlans.find(plan => plan.userId === userId);
        
        if (existingPlan) {
            // Mettre √† jour le plan existant
            const updatedPlan = {
                ...existingPlan,
                plan: 'entreprise',
                status: 'active',
                updatedAt: new Date(),
                features: {
                    calendar: true,
                    advancedReports: true,
                    prioritySupport: true,
                    unlimitedProperties: true
                }
            };
            
            await firestoreUtils.update('billingPlans', existingPlan.id, updatedPlan);
        } else {
            // Cr√©er un nouveau plan
            const newPlan = {
                userId: userId,
                userEmail: req.session.user.email,
                plan: 'entreprise',
                status: 'active',
                startDate: new Date(),
                endDate: new Date(Date.now() + 365 * 24 * 60 * 60 * 1000), // 1 an
                price: 290,
                currency: 'EUR',
                features: {
                    calendar: true,
                    advancedReports: true,
                    prioritySupport: true,
                    unlimitedProperties: true
                },
                createdAt: new Date(),
                updatedAt: new Date()
            };
            
            await firestoreUtils.add('billingPlans', newPlan);
        }

        res.json({ 
            success: true, 
            message: 'Plan entreprise configur√© avec succ√®s',
            plan: { plan: 'entreprise', status: 'active' }
        });

    } catch (error) {
        console.error('Erreur lors de la configuration du plan entreprise:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Erreur lors de la configuration du plan entreprise' 
        });
    }
});

// API pour ajouter un √©v√©nement automatique (appel√© depuis d'autres routes)
router.post('/api/add-automatic-event', async (req, res) => {
    try {
        const { userId, eventType, propertyId, title, description, eventDate } = req.body;

        if (!userId || !eventType || !title) {
            return res.status(400).json({ 
                success: false, 
                message: 'Param√®tres requis manquants' 
            });
        }

        const eventData = {
            id: generateEventId(),
            title: title,
            description: description || '',
            start: new Date(eventDate || Date.now()),
            end: new Date(Date.now() + 60 * 60 * 1000), // 1 heure plus tard
            propertyId: propertyId || null,
            eventType: eventType,
            location: '',
            userId: userId,
            createdAt: new Date(),
            isAutomatic: true,
            googleCalendarId: null
        };

        // Sauvegarder l'√©v√©nement automatique
        await saveCalendarEvent(eventData);

        res.json({ 
            success: true, 
            event: eventData,
            message: '√âv√©nement automatique ajout√© avec succ√®s'
        });

    } catch (error) {
        console.error('Erreur lors de l\'ajout de l\'√©v√©nement automatique:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Erreur lors de l\'ajout de l\'√©v√©nement automatique' 
        });
    }
});

// API pour v√©rifier l'authentification Google
router.get('/api/check-google-auth', checkUserPlan, async (req, res) => {
    try {

        // V√©rifier si l'utilisateur a des tokens Google stock√©s
        const user = await firestoreUtils.getById('users', req.session.user.id);
        
        if (user && user.googleTokens && user.googleTokens.access_token) {
            // V√©rifier si le token est encore valide (optionnel)
            res.json({ 
                success: true, 
                authenticated: true,
                message: 'Utilisateur authentifi√© avec Google'
            });
        } else {
            res.json({ 
                success: true, 
                authenticated: false,
                message: 'Utilisateur non authentifi√© avec Google'
            });
        }

    } catch (error) {
        console.error('Erreur lors de la v√©rification de l\'authentification Google:', error);
        res.status(500).json({ 
            success: false, 
            authenticated: false,
            message: 'Erreur lors de la v√©rification de l\'authentification Google' 
        });
    }
});

// API pour synchroniser avec Google Calendar
router.post('/api/sync-google', checkUserPlan, async (req, res) => {
    try {

        // V√©rifier si l'utilisateur est authentifi√© avec Google
        const user = await firestoreUtils.getById('users', req.session.user.id);
        
        if (!user || !user.googleTokens || !user.googleTokens.access_token) {
            return res.status(401).json({ 
                success: false, 
                message: 'Vous devez d\'abord vous connecter avec Google pour synchroniser votre calendrier' 
            });
        }

        // Synchroniser tous les √©v√©nements avec Google Calendar
        const events = await getCalendarEvents(req.session.user.id);
        const syncResults = [];

        for (const event of events) {
            try {
                const googleEventId = await syncWithGoogleCalendar(event, req.session.user);
                if (googleEventId) {
                    await updateCalendarEvent(event.id, { googleCalendarId: googleEventId });
                    syncResults.push({ eventId: event.id, success: true });
                }
            } catch (error) {
                console.error(`Erreur sync pour l'√©v√©nement ${event.id}:`, error);
                syncResults.push({ eventId: event.id, success: false, error: error.message });
            }
        }

        res.json({ 
            success: true, 
            results: syncResults,
            message: 'Synchronisation termin√©e'
        });

    } catch (error) {
        console.error('Erreur lors de la synchronisation:', error);
        res.status(500).json({ 
            success: false, 
            message: 'Erreur lors de la synchronisation avec Google Calendar' 
        });
    }
});

// Fonctions utilitaires pour la gestion des √©v√©nements

async function generatePaymentEvents(userId) {
    const paymentEvents = [];
    
    try {
        console.log('üí∞ Calcul des √©ch√©ances de loyer bas√©es sur les dates d\'entr√©e des locataires...');
        
        if (!firestoreUtils.isInitialized()) {
            console.log('‚ùå Firebase non initialis√© - aucun √©v√©nement de paiement g√©n√©r√©');
            return paymentEvents;
        }
        
        // R√©cup√©rer toutes les collections pour debug
        console.log('üîç D√©bogage des collections Firebase...');
        
        const [payments, properties, users] = await Promise.all([
            //firestoreUtils.getAll('tenants').catch(err => { console.log('‚ùå Erreur collection tenants:', err.message); return []; }),
            firestoreUtils.getAll('payments').catch(err => { console.log('‚ùå Erreur collection payments:', err.message); return []; }),
            firestoreUtils.getAll('properties').catch(err => { console.log('‚ùå Erreur collection properties:', err.message); return []; }),
            firestoreUtils.getAll('users').catch(err => { console.log('‚ùå Erreur collection users:', err.message); return []; })
        ]);
        const userProperties = properties.filter(property => property.ownerId === userId || property.userId === userId);
        const tenantUserIds = userProperties.filter(property => property.tenant).map(property => property.tenant.userId);
        const tenants = users.filter(user => tenantUserIds.includes(user.userId));
        
        const properieIds = userProperties.map(property => property.id);
        const userPayments = payments.filter(payment => properieIds.includes(payment.propertyId));
        
        // Debug des structures de donn√©es
        /*if (tenants.length > 0) {
            console.log('üìã Structure du premier locataire:', JSON.stringify(tenants[0], null, 2));
        }
        if (payments.length > 0) {
            console.log('üí∞ Structure du premier paiement:', JSON.stringify(payments[0], null, 2));
        }
        if (properties.length > 0) {
            console.log('üè† Structure de la premi√®re propri√©t√©:', JSON.stringify(properties[0], null, 2));
        }*/
        
        // Filtrer les locataires de l'utilisateur
        /*let userTenants = [];
        
        console.log(`üë§ ${userTenants.length} locataires pour l'utilisateur ${userId}`);
        
        // Si pas de locataires, essayer d'utiliser les propri√©t√©s avec des locataires
        if (userTenants.length === 0 && properties.length > 0) {
            //console.log('üîÑ Aucun locataire trouv√©, utilisation des propri√©t√©s avec locataires...');
            userTenants = properties.filter(property => 
                (property.ownerId) &&
                (property.tenant || property.status === 'rented')
            ).map(property => ({
                id: property.tenant.userId,
                propertyId: property.id,
                propertyName: property.name || property.title,
                propertyAddress: property.address || property.location,
                ownerId: property.ownerId || userId,
                loyer: property.rent || property.monthlyRent,
                monthlyRent: property.rent || property.monthlyRent,
                dateEntree: property.tenant.entryDate || property.entryDate || new Date().toISOString().split('T')[0],
                entryDate: property.tenant.entryDate || property.entryDate || new Date().toISOString().split('T')[0]
            }));
            console.log(`üè† ${userTenants.length} propri√©t√©s avec locataires trouv√©es`);
        }*/        
        // Calculer les √©ch√©ances pour chaque locataire bas√©es sur sa date d'entr√©e
        

        /*for(property of userProperties) {
            const entryDate = new Date(property.entryDate || new Date().toISOString().split('T')[0]);
            const createdDate = new Date(property.createdAt || new Date().toISOString().split('T')[0]);
            const createdMonth = createdDate.getMonth();
            const createdYear = createdDate.getFullYear();
            const now = new Date();
            const currentMonth = now.getMonth();
            const currentYear = now.getFullYear();
            const monthsSinceCreated = (currentYear - createdYear) * 12 + (currentMonth - createdMonth);
            const tenant = users.find(user => user.userId === property.tenant.userId);
            for(let i = 0; i < monthsSinceCreated; i++) {
                const dueDate = new Date(createdYear, createdMonth + i, 1);
                const dueDateEnd = new Date(dueDate.getTime() + 24 * 60 * 60 * 1000);
                const paymentEvent = {
                    id: `rent_due_${property.id}_${dueDate.getFullYear()}_${dueDate.getMonth()}`,
                    title: `√âch√©ance loyer - ${property.name || property.title}`,
                    description: `√âch√©ance loyer: ${property.rent || property.monthlyRent || 0} xaf`,
                    start: dueDate,
                    end: dueDateEnd,
                    propertyId: property.id,
                    eventType: 'paiement',
                    location: property.address || property.location || '',
                    userId: userId,
                    isAutomatic: true,
                    googleCalendarId: null,
                    tenantId: property.tenant.userId,
                    tenantName: tenant.name || tenant.firstName + ' ' + tenant.lastName,
                    entryDate: entryDate.toISOString()
                };
                paymentEvents.push(paymentEvent);
                console.log(`  üí≥ ${dueDate.toLocaleDateString()}: ${property.rent || property.monthlyRent || 0} xaf - paiement`);
            }
         }
        */
        //Ech√©ances de loyer re√ßus
        for(payment of userPayments) {
            const dueDate = new Date(payment.date || payment.createdAt);
            const dueDateEnd = new Date(dueDate.getTime() + 24 * 60 * 60 * 1000);
            const property = properties.find(property => property.id === payment.propertyId);
            const tenant = users.find(user => user.id === payment.userId);
            console.log('payment', payment);
            const paymentEvent = {
                id: `rent_due_${property.id}_${dueDate.getFullYear()}_${dueDate.getMonth()}`,
                title: `√âch√©ance loyer - ${property.name || property.title}`,
                description: `√âch√©ance loyer: ${property.rent || property.monthlyRent || 0} xaf`,
                start: dueDate,
                end: dueDateEnd,
                propertyId: property.id,
                eventType: 'paiement_re√ßu',
                location: property.address || property.location || '',
                userId: payment.userId,
                isAutomatic: true,
                googleCalendarId: null,
                tenantId: payment.userId,
                tenantName: tenant.profile.firstName + ' ' + tenant.profile.lastName,
            };
            paymentEvents.push(paymentEvent);
            console.log(`  üí≥ ${dueDate.toLocaleDateString()}: ${property.rent || property.monthlyRent || 0} xaf - paiement`);
            
        }
        
        console.log(`‚úÖ ${paymentEvents.length} √©ch√©ances de loyer calcul√©es`);
        
        // Debug final
        if (paymentEvents.length === 0) {
            console.log('‚ö†Ô∏è Aucune √©ch√©ance g√©n√©r√©e. V√©rifiez:');
            console.log('  - Les collections tenants/payments existent-elles ?');
            console.log('  - Y a-t-il des locataires pour cet utilisateur ?');
            console.log('  - Les propri√©t√©s ont-elles des locataires ?');
            console.log('  - Les dates d\'entr√©e sont-elles valides ?');
        } else {
            console.log('üéâ √âch√©ances g√©n√©r√©es avec succ√®s:');
            paymentEvents.slice(0, 3).forEach(event => {
                console.log(`  üìÖ ${event.start.toLocaleDateString()}: ${event.title} (${event.eventType})`);
            });
            if (paymentEvents.length > 3) {
                console.log(`  ... et ${paymentEvents.length - 3} autres √©ch√©ances`);
            }
        }
        
    } catch (error) {
        console.error('‚ùå Erreur lors du calcul des √©ch√©ances de loyer:', error);
    }
    
    return paymentEvents;
}


async function generateAutomaticEvents(properties, userId) {
    const automaticEvents = [];
    
    console.log('üîç R√©cup√©ration des √©v√©nements automatiques depuis la base de donn√©es...');
    
    if (!firestoreUtils.isInitialized()) {
        console.log('‚ùå Firebase non initialis√© - aucun √©v√©nement automatique g√©n√©r√©');
        return automaticEvents;
    }
    
    try {
        // R√©cup√©rer les √©v√©nements de calendrier r√©els depuis Firebase
        const calendarEvents = await firestoreUtils.getAll('calendarEvents');
        console.log(`üìä ${calendarEvents.length} √©v√©nements de calendrier trouv√©s dans la base de donn√©es`);
        
        // Filtrer les √©v√©nements de l'utilisateur
        const userEvents = calendarEvents.filter(event => 
            event.userId === userId || event.ownerId === userId
        );
        
        console.log(`üë§ ${userEvents.length} √©v√©nements pour l'utilisateur ${userId}`);
        
        // Convertir les √©v√©nements r√©els en format calendrier
        userEvents.forEach(event => {
            // Convertir les dates Firebase Timestamp en Date JavaScript
            let startDate, endDate;
            
            if (event.start && typeof event.start === 'object' && event.start.seconds) {
                // Format Firebase Timestamp
                startDate = new Date(event.start.seconds * 1000);
            } else if (event.start) {
                // Format ISO string ou autre
                startDate = new Date(event.start);
            } else if (event.date) {
                // Fallback sur event.date
                startDate = new Date(event.date);
            } else {
                console.log(`‚ö†Ô∏è Aucune date de d√©but trouv√©e pour l'√©v√©nement ${event.id}, ignor√©`);
                return;
            }
            
            if (event.end && typeof event.end === 'object' && event.end.seconds) {
                // Format Firebase Timestamp
                endDate = new Date(event.end.seconds * 1000);
            } else if (event.end) {
                // Format ISO string ou autre
                endDate = new Date(event.end);
            } else {
                // Par d√©faut, fin de journ√©e
                endDate = new Date(startDate.getTime() + 24 * 60 * 60 * 1000);
            }
            
            // V√©rifier que les dates sont valides
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                console.log(`‚ö†Ô∏è Date invalide pour l'√©v√©nement ${event.id}, ignor√©`);
                return;
            }
            
            const calendarEvent = {
                id: event.id,
                title: event.title,
                description: event.description || '',
                start: startDate,
                end: endDate,
                propertyId: event.propertyId || null,
                eventType: event.eventType || event.type || 'custom',
                location: event.location || '',
                userId: userId,
                isAutomatic: event.isAutomatic || false,
                googleCalendarId: event.googleCalendarId || null
            };
            
            automaticEvents.push(calendarEvent);
            console.log(`  üìÖ √âv√©nement r√©el: ${calendarEvent.title} - ${startDate.toLocaleDateString()}`);
        });
        
        console.log(`‚úÖ ${automaticEvents.length} √©v√©nements automatiques r√©els r√©cup√©r√©s`);
        
        // G√©n√©rer des √©v√©nements automatiques bas√©s sur les propri√©t√©s
        console.log('üè† G√©n√©ration d\'√©v√©nements automatiques bas√©s sur les propri√©t√©s...');
        
        for (const property of properties) {
            console.log(`üìã Traitement de la propri√©t√©: ${property.name || property.title || property.id}`);
            
            // √âv√©nement de cr√©ation de propri√©t√©
            if (property.createdAt) {
                const creationDate = new Date(property.createdAt);
                if (!isNaN(creationDate.getTime())) {
                    automaticEvents.push({
                        id: `property_creation_${property.id}`,
                        title: `Propri√©t√© cr√©√©e - ${property.name || property.title || 'Nouvelle propri√©t√©'}`,
                        description: `Propri√©t√© ajout√©e au portfolio`,
                        start: creationDate,
                        end: new Date(creationDate.getTime() + 24 * 60 * 60 * 1000),
                        propertyId: property.id,
                        eventType: 'creation_propriete',
                        location: property.address || '',
                        userId: userId,
                        isAutomatic: true,
                        googleCalendarId: null
                    });
                    console.log(`  ‚úÖ Cr√©ation: ${creationDate.toLocaleDateString()}`);
                }
            }
            
            // √âv√©nement de visite planifi√©e (si la propri√©t√© est libre)
            if (property.status === 'available' || property.status === 'libre') {
                // G√©n√©rer une visite planifi√©e avec une date fixe bas√©e sur l'ID de la propri√©t√©
                const visitDate = new Date();
                const dayOffset = (property.id.charCodeAt(0) + property.id.length) % 7; // Date bas√©e sur l'ID
                visitDate.setDate(visitDate.getDate() + dayOffset + 1);
                visitDate.setHours(14, 0, 0, 0); // 14h00
                
                automaticEvents.push({
                    id: `visit_planned_${property.id}_fixed`,
                    title: `Visite planifi√©e - ${property.name || property.title || 'Propri√©t√©'}`,
                    description: `Visite de la propri√©t√© programm√©e`,
                    start: visitDate,
                    end: new Date(visitDate.getTime() + 2 * 60 * 60 * 1000), // 2 heures
                    propertyId: property.id,
                    eventType: 'visite_planifie',
                    location: property.address || '',
                    userId: userId,
                    isAutomatic: true,
                    googleCalendarId: null
                });
                console.log(`  üè† Visite: ${visitDate.toLocaleDateString()}`);
            }
            
            // √âv√©nement de maintenance (pour les propri√©t√©s occup√©es)
            if (property.status === 'rented' || property.status === 'occupied') {
                // G√©n√©rer un √©v√©nement de maintenance avec une date fixe bas√©e sur l'ID de la propri√©t√©
                const maintenanceDate = new Date();
                const dayOffset = (property.id.charCodeAt(0) + property.id.length) % 30; // Date bas√©e sur l'ID
                maintenanceDate.setDate(maintenanceDate.getDate() + dayOffset + 1);
                maintenanceDate.setHours(10, 0, 0, 0); // 10h00
                
                automaticEvents.push({
                    id: `maintenance_${property.id}_fixed`,
                    title: `Maintenance - ${property.name || property.title || 'Propri√©t√©'}`,
                    description: `V√©rification et maintenance de la propri√©t√©`,
                    start: maintenanceDate,
                    end: new Date(maintenanceDate.getTime() + 4 * 60 * 60 * 1000), // 4 heures
                    propertyId: property.id,
                    eventType: 'maintenance',
                    location: property.address || '',
                    userId: userId,
                    isAutomatic: true,
                    googleCalendarId: null
                });
                console.log(`  üîß Maintenance: ${maintenanceDate.toLocaleDateString()}`);
            }
            
            // √âv√©nement d'expiration de bail (si un locataire est pr√©sent)
            if (property.tenant && property.tenant.leaseEnd) {
                const leaseEndDate = new Date(property.tenant.leaseEnd);
                if (!isNaN(leaseEndDate.getTime())) {
                    automaticEvents.push({
                        id: `lease_expiry_${property.id}`,
                        title: `Expiration bail - ${property.name || property.title || 'Propri√©t√©'}`,
                        description: `Fin de contrat de location`,
                        start: leaseEndDate,
                        end: new Date(leaseEndDate.getTime() + 24 * 60 * 60 * 1000),
                        propertyId: property.id,
                        eventType: 'expiration_bail',
                        location: property.address || '',
                        userId: userId,
                        isAutomatic: true,
                        googleCalendarId: null,
                        tenantId: property.tenant.userId || property.tenant.id
                    });
                    console.log(`  üìÑ Expiration bail: ${leaseEndDate.toLocaleDateString()}`);
                }
            }
        }
        
        console.log(`‚úÖ ${automaticEvents.length} √©v√©nements automatiques g√©n√©r√©s (${automaticEvents.length - properties.length} de la DB + ${properties.length} g√©n√©r√©s)`);
        
    } catch (error) {
        console.error('‚ùå Erreur lors de la r√©cup√©ration des √©v√©nements automatiques:', error);
    }
    
    return automaticEvents;
}

async function getUserBillingPlan(userId) {
    try {
        if (!firestoreUtils.isInitialized()) {
            // Pour les tests, retourner un plan entreprise
            console.log('Firebase non initialis√© - mode test: plan entreprise');
            return { plan: 'entreprise', status: 'active' };
        }

        const billingPlans = await firestoreUtils.getAll('billingPlans');
        console.log('Plans de facturation trouv√©s:', billingPlans.length);
        
        const userPlan = billingPlans.find(plan => plan.userId === userId);
        console.log('Plan utilisateur trouv√©:', userPlan);
        
        if (userPlan) {
            return userPlan;
        }
        
        // Si aucun plan trouv√©, v√©rifier si l'utilisateur a des propri√©t√©s (indicateur d'usage)
        // En attendant la mise en place compl√®te du syst√®me de facturation
        const properties = await firestoreUtils.getAll('properties');
        const userProperties = properties.filter(property => 
            property.ownerId === userId || property.tenantId === userId
        );
        
        if (userProperties.length > 0) {
            console.log('Utilisateur avec propri√©t√©s d√©tect√© - acc√®s entreprise temporaire');
            return { plan: 'entreprise', status: 'active' };
        }
        
        return { plan: 'gratuit', status: 'active' };
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration du plan:', error);
        // En cas d'erreur, permettre l'acc√®s temporairement
        return { plan: 'entreprise', status: 'active' };
    }
}

async function getPropertiesFromDatabase() {
    try {
        if (!firestoreUtils.isInitialized()) {
            return getMockProperties();
        }

        const properties = await firestoreUtils.getAll('properties');
        return properties.map(property => ({
            id: property.id,
            title: property.name || `Propri√©t√© ${property.id}`,
            address: property.address || 'Adresse non sp√©cifi√©e',
            city: property.city || 'Ville non sp√©cifi√©e',
            ownerId: property.ownerId || null,
            tenantId: property.tenantId || null,
            rent: property.rent || property.monthlyRent || 0
        }));
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des propri√©t√©s:', error);
        return getMockProperties();
    }
}

async function getCalendarEvents(userId, filters = {}) {
    try {
        if (!firestoreUtils.isInitialized()) {
            return getMockCalendarEvents(userId, filters);
        }

        let events = await firestoreUtils.getAll('calendarEvents');
        
        // Filtrer par utilisateur
        events = events.filter(event => event.userId === userId);
        
        // Appliquer les filtres
        if (filters.start) {
            events = events.filter(event => {
                let eventStart;
                if (event.start && typeof event.start === 'object' && event.start.seconds) {
                    eventStart = new Date(event.start.seconds * 1000);
                } else if (event.start) {
                    eventStart = new Date(event.start);
                } else {
                    return false;
                }
                return eventStart >= filters.start;
            });
        }
        if (filters.end) {
            events = events.filter(event => {
                let eventEnd;
                if (event.end && typeof event.end === 'object' && event.end.seconds) {
                    eventEnd = new Date(event.end.seconds * 1000);
                } else if (event.end) {
                    eventEnd = new Date(event.end);
                } else {
                    return false;
                }
                return eventEnd <= filters.end;
            });
        }
        if (filters.propertyId) {
            events = events.filter(event => event.propertyId === filters.propertyId);
        }

        return events.map(event => {
            // Convertir les dates Firebase Timestamp en Date JavaScript
            let startDate, endDate;
            
            if (event.start && typeof event.start === 'object' && event.start.seconds) {
                // Format Firebase Timestamp
                startDate = new Date(event.start.seconds * 1000);
            } else if (event.start) {
                // Format ISO string ou autre
                startDate = new Date(event.start);
            } else {
                startDate = new Date();
            }
            
            if (event.end && typeof event.end === 'object' && event.end.seconds) {
                // Format Firebase Timestamp
                endDate = new Date(event.end.seconds * 1000);
            } else if (event.end) {
                // Format ISO string ou autre
                endDate = new Date(event.end);
            } else {
                // Par d√©faut, fin de journ√©e
                endDate = new Date(startDate.getTime() + 24 * 60 * 60 * 1000);
            }
            
            return {
                id: event.id,
                title: event.title,
                description: event.description || '',
                start: startDate,
                end: endDate,
                propertyId: event.propertyId || null,
                eventType: event.eventType || 'custom',
                location: event.location || '',
                googleCalendarId: event.googleCalendarId || null
            };
        });
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration des √©v√©nements:', error);
        return getMockCalendarEvents(userId, filters);
    }
}

async function saveCalendarEvent(eventData) {
    try {
        if (!firestoreUtils.isInitialized()) {
            console.log('Mode test: √©v√©nement sauvegard√©:', eventData);
            return eventData;
        }

        await firestoreUtils.add('calendarEvents', eventData);
        return eventData;
    } catch (error) {
        console.error('Erreur lors de la sauvegarde de l\'√©v√©nement:', error);
        throw error;
    }
}

async function getCalendarEventById(eventId) {
    try {
        if (!firestoreUtils.isInitialized()) {
            const mockEvents = getMockCalendarEvents();
            return mockEvents.find(event => event.id === eventId);
        }

        const events = await firestoreUtils.getAll('calendarEvents');
        return events.find(event => event.id === eventId);
    } catch (error) {
        console.error('Erreur lors de la r√©cup√©ration de l\'√©v√©nement:', error);
        return null;
    }
}

async function updateCalendarEvent(eventId, updates) {
    try {
        if (!firestoreUtils.isInitialized()) {
            console.log('Mode test: √©v√©nement mis √† jour:', eventId, updates);
            return { id: eventId, ...updates };
        }

        await firestoreUtils.update('calendarEvents', eventId, updates);
        return { id: eventId, ...updates };
    } catch (error) {
        console.error('Erreur lors de la mise √† jour de l\'√©v√©nement:', error);
        throw error;
    }
}

async function deleteCalendarEvent(eventId) {
    try {
        if (!firestoreUtils.isInitialized()) {
            console.log('Mode test: √©v√©nement supprim√©:', eventId);
            return true;
        }

        await firestoreUtils.delete('calendarEvents', eventId);
        console.log('√âv√©nement supprim√©:', eventId);
        
        return true;
    } catch (error) {
        console.error('Erreur lors de la suppression de l\'√©v√©nement:', error);
        throw error;
    }
}

// Fonctions pour l'int√©gration Google Calendar (√† impl√©menter plus tard)
async function syncWithGoogleCalendar(eventData, user) {
    // TODO: Impl√©menter l'int√©gration Google Calendar API
    console.log('Sync avec Google Calendar:', eventData);
    return `google_event_${Date.now()}`;
}

async function updateGoogleCalendarEvent(googleEventId, updates) {
    // TODO: Impl√©menter la mise √† jour Google Calendar API
    console.log('Mise √† jour Google Calendar:', googleEventId, updates);
}

async function deleteGoogleCalendarEvent(googleEventId) {
    // TODO: Impl√©menter la suppression Google Calendar API
    console.log('Suppression Google Calendar:', googleEventId);
}

// Donn√©es de test
function getMockProperties() {
    return [
        {
            id: '1',
            title: 'Appartement T3 moderne',
            address: '123 Rue de la Paix, Paris 15√®me',
            location: '123 Rue de la Paix, Paris 15√®me',
            city: 'Paris',
            ownerId: 'user1',
            tenantId: 'user2',
            rent: 1200,
            monthlyRent: 1200,
            occupied: true
        },
        {
            id: '2',
            title: 'Studio cosy',
            address: '456 Avenue des Champs, Lyon 2√®me',
            location: '456 Avenue des Champs, Lyon 2√®me',
            city: 'Lyon',
            ownerId: 'user1',
            tenantId: 'user3',
            rent: 650,
            monthlyRent: 650,
            occupied: true
        },
        {
            id: '3',
            title: 'Maison T4 avec jardin',
            address: '789 Boulevard de la R√©publique, Marseille',
            location: '789 Boulevard de la R√©publique, Marseille',
            city: 'Marseille',
            ownerId: 'user1',
            tenantId: 'user4',
            rent: 1500,
            monthlyRent: 1500,
            occupied: true
        }
    ];
}


function getMockCalendarEvents(userId, filters = {}) {
    const events = [
        {
            id: 'event1',
            title: 'Visite propri√©t√© - Appartement T3',
            description: 'Visite pr√©vue pour un locataire potentiel',
            start: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000), // Dans 2 jours
            end: new Date(Date.now() + 2 * 24 * 60 * 60 * 1000 + 60 * 60 * 1000), // 1 heure plus tard
            propertyId: '1',
            eventType: 'visite',
            location: '123 Rue de la Paix, Paris 15√®me',
            userId: userId,
            googleCalendarId: null
        },
        {
            id: 'event2',
            title: '√âch√©ance loyer - Studio cosy',
            description: 'Paiement du loyer mensuel',
            start: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000), // Dans 5 jours
            end: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000),
            propertyId: '2',
            eventType: 'paiement',
            location: '',
            userId: userId,
            googleCalendarId: null
        },
        {
            id: 'event3',
            title: 'Expiration bail - Appartement T3',
            description: 'Fin du bail locatif - renouvellement ou d√©part',
            start: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000), // Dans 30 jours
            end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
            propertyId: '1',
            eventType: 'expiration',
            location: '',
            userId: userId,
            googleCalendarId: null
        }
    ];

    // Appliquer les filtres
    let filteredEvents = events.filter(event => event.userId === userId);
    
    if (filters.start) {
        filteredEvents = filteredEvents.filter(event => new Date(event.start) >= filters.start);
    }
    if (filters.end) {
        filteredEvents = filteredEvents.filter(event => new Date(event.end) <= filters.end);
    }
    if (filters.propertyId) {
        filteredEvents = filteredEvents.filter(event => event.propertyId === filters.propertyId);
    }

    return filteredEvents;
}

function generateEventId() {
    return `event_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
}

module.exports = router;
